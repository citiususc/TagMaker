{% extends 'base.html' %}
{% csrf_token %}
{% load static %}
{% load i18n %}
{% block content %}

    <style>
    .main-section .container{
        padding-left: 0px;
        padding-right: 0px;
        margin-right: 0px;
        margin-left: 0px;
        max-width: 100%;
    }

    .main-section .container .main{
        margin-top: 20px;
        margin-bottom: 0px;
    }

    #back{
        margin-left: 75px;
    }



.wrapper {
    display: flex;
    width: 100%;
    align-items: stretch;
}

#sidebar {
    min-width: 300px;
    max-width: 300px;
    transition: all 0.3s;
    text-align: center;
    height: auto;
}

#sidebar.active {
    margin-left: -300px;
}

.table-tags {
    width: 50%;
    margin: 0px auto;
    float: none;
}


#content {
    padding: 20px;
    width: 100%;
    transition: all 0.3s;
}

#sidebarCollapse{
    padding:0px;
    margin-left: 5px;
    background-color: #bfbfbf;
}

@media (max-width: 768px) {
    #sidebar {
        margin-left: -250px;
    }
    #sidebar.active {
        margin-left: 0;
    }
    #sidebarCollapse span {
        display: none;
    }
}


</style>
<a id="back" href="{% url 'images_experiment' id=exp.id %}"><i class="fas fa-arrow-left"></i> {% trans "BACK" %}</a>
    <div class="main">
        <div class="alert-annotate">
            <div class="alert alert-success alert-dismissible fade show" role="alert">
                {% trans "Annotations" %} <strong id="text-alert"></strong>!
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        </div>

    <div class="wrapper">
        <div id="sidebar">
                        <table class="table text-center table-tags">
                            <caption>{% trans "Defined annotations" %}</caption>
                            <tbody>
                            {% for at in annotation_types %}
                                <tr>
                                    {% if at.primitive == "Point" %}
                                        <td><a href="#" onclick="point('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                        <td><i class="fas fa-circle" style="color: {{ at.color }}"></i></td>

                                    {% elif at.primitive == "Box" %}
                                        <td><a href="#" onclick="box('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                        <td><i class="far fa-square" style="color: {{ at.color }}"></i></td>

                                    {% elif at.primitive == "Polygon" %}
                                    <td><a href="#" onclick="polygon('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                    <td><i class="fas fa-draw-polygon" style="color: {{ at.color }}"></i></td>

                                    {% elif at.primitive == "Curve" %}
                                    <td><a href="#" onclick="curved('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                    <td><i class="fas fa-signature" style="color: {{ at.color }}"></i></td>
                                    {% endif %}
                                </tr>
                            {% endfor %}
                            </tbody>
                        </table><br>
                        <button class="btn btn-secondary w-50" onclick="save();"> {% trans "Save" %}</button>
                        {% if user.is_authenticated and user.is_staff and tag_image and not tag_image.user.is_staff %}
                            <button class="btn btn-primary" onclick="validate();">{% trans "Validate" %}</button>
                        {% endif %}
        </div>

    <button type="button" id="sidebarCollapse" class="btn">
        <i class="fas fa-angle-double-left"></i>
    </button>

        <div id="content">
                        {% if tag_image is not None %}
                            <p><i class="fas fa-edit"></i> {% trans "Annotated by" %} <b>{{ tag_image.user }}</b></p>
                        {% else %}
                            <p>{% trans "There isn't any annotation yet" %}</p>
                        {% endif %}


        <button class="btn btn-secondary" title="{% trans 'zoom in' %}" onclick="zoom_in();"><i class="fas fa-search-plus"></i></button>
        <button class="btn btn-secondary" title="{% trans 'zoom out' %}" onclick="zoom_out();"><i class="fas fa-search-minus"></i></button>
        <button class="btn btn-secondary" title="{% trans 'panning' %}" onclick="do_panning();"><i class="far fa-hand-paper"></i></button>
        <button class="btn btn-primary" title="{% trans 'select tags' %}" onclick="select_tag();" title="select annotation"><i class="fas fa-mouse-pointer"></i></button>
        <button id="button-delete" title="{% trans 'delete tags selected' %}" class="btn btn-danger" onclick="delete_tag();" title="delete annotation"><i class="fas fa-trash-alt"></i></button>


        <div id="container_canvas">
             <canvas id="myCanvas">
            Your browser does not support the HTML5 canvas tag
            </canvas>
        </div>
        </div>
    </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.3/js/materialize.min.js"></script>

    <script src="{% static "js/fabric.js" %}" type="text/javascript"></script>
    <script type="text/javascript" src="{% url 'javascript-catalog' %}"></script>
    <script type="text/javascript">

        let container = document.getElementById("container_canvas");
        let canvas = new fabric.Canvas('myCanvas');

        var proporcion = 1;


        fabric.Group.prototype.hasControls = false;
        fabric.Object.NUM_FRACTION_DIGITS = 10;
        fabric.Group.prototype.lockScalingX = true;
        fabric.Group.prototype.lockScalingY = true;


        let pointerdown = false;
        let factorScale = 1.0;
        var scaleX = 1.0;
        var scaleY = 1.0;
        var canvas_width = window.innerWidth-380.0;
        var stroke = 1.5;


        function resizeCanvas(newWidth){

            if (canvas.getWidth() != newWidth){
                factorScale = newWidth/canvas.getWidth();
                canvas.setWidth(canvas.getWidth()*factorScale);
                canvas_width = canvas.width;
                canvas.setHeight(canvas.getHeight()*factorScale);

                canvas.discardActiveObject();


                canvas.getObjects().forEach((obj) => {
                        obj.scaleX = obj.scaleX * factorScale;
                        obj.scaleY = obj.scaleY * factorScale;
                        scaleX = obj.scaleX;
                        scaleY = obj.scaleY;
                        obj.left = obj.left * factorScale;
                        obj.top = obj.top * factorScale;
                        obj.setCoords();
                });


                canvas.backgroundImage.scaleToWidth(canvas.getWidth(), canvas.renderAll.bind(canvas));

            }
        }


        $(window).resize(function(){
            //comprobación si está abierta o cerrada la barra lateral
            if(document.getElementById("sidebar").classList.contains('active')){
                resizeCanvas(window.innerWidth-50.0);

            }
            else{
                resizeCanvas(window.innerWidth-380.0);
            }
        });

        fabric.Image.fromURL('/{{ image.path }}/{{ image.name_unique }}', function (img) {
                proporcion = img.width/img.height;
                canvas.setWidth(window.innerWidth-380.0);
                canvas.setHeight((window.innerWidth-380.0)/proporcion);
                img.scaleToWidth(canvas.getWidth(), canvas.renderAll.bind(canvas));
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));

                load();
                 document.getElementById("button-delete").disabled = true;

        });

        $(document).ready(function () {
            $('#sidebarCollapse').on('click', function () {
                $('#sidebar').toggleClass('active');
                $('.fa-angle-double-left').toggleClass('fa-angle-double-right');
                if (canvas.width == window.innerWidth-50.0){
                    resizeCanvas(window.innerWidth-380.0);
                }
                else{
                    resizeCanvas(window.innerWidth-50.0);
                }
            });
        });

        function zoom_in(pos_x, pos_y){
            if(pos_x && pos_y){
                canvas.zoomToPoint(new fabric.Point(pos_x, pos_y), canvas.getZoom() * 1.1);
            }else{
                canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), canvas.getZoom() * 1.1);
            }
            var scale = 1 / canvas.getZoom();
            canvas.forEachObject(function(obj){
                if(obj.type == 'circle'){
                    obj.scaleX = (scale || 1) * 1.1;
                    scaleX = obj.scaleX;
                    obj.scaleY = (scale || 1) * 1.1;
                    scaleY = obj.scaleY;
                }
                if(obj.type == 'rect' || obj.type == 'polyline' || obj.type == 'polygon'){
                     obj.strokeWidth = 1.5*scale;
                     stroke = obj.strokeWidth;

                }
            });
        }

        function zoom_out(pos_x,pos_y){
            if (canvas.getZoom()>1){
                if(pos_x && pos_y){
                    canvas.zoomToPoint(new fabric.Point(pos_x, pos_y), canvas.getZoom() / 1.1);
                }else{
                    canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), canvas.getZoom() / 1.1);
                }
                var scale = 1 / canvas.getZoom();
                canvas.forEachObject(function(obj){
                    if(obj.type == 'circle') {
                        obj.scaleX = (scale || 1) / 1.1;
                        scaleX = obj.scaleX;
                        obj.scaleY = (scale || 1) / 1.1;
                        scaleY = obj.scaleY;
                    }
                    if(obj.type == 'rect' || obj.type == 'polyline' || obj.type == 'polygon'){
                        obj.strokeWidth = 1.5*scale;
                        stroke = obj.strokeWidth;
                    }
                });
            }
        }




        container.addEventListener('wheel', function(evt){
            const delta = Math.sign(evt.deltaY);
            var pointer = canvas.getPointer(evt.e);
                pos_x = pointer.x;
                pos_y = pointer.y;
            if (delta == -1){ //zoom in
                evt.preventDefault();
                zoom_in(pos_x, pos_y);
            }else if(delta == 1){ //zoom out
                evt.preventDefault();
                zoom_out(pos_x, pos_y);
            }
        });



        var panning = false;
        function do_panning(){
            removeEvents();

            canvas.on('mouse:up', function () {
                panning = false;
            });

            canvas.on('mouse:down', function () {
                panning = true;
            });

            canvas.on('mouse:move', move_panning);
        }





        function move_panning(evt){
                if (panning && evt && evt.e) {
                    var delta = new fabric.Point(evt.e.movementX, evt.e.movementY);
                    canvas.relativePan(delta);

                    var canvasViewPort = canvas.viewportTransform;


                    var bottomEndPoint = canvas.height * (canvasViewPort[0] - 1);
                    if(canvasViewPort[5] >= 0 || -bottomEndPoint > canvasViewPort[5]) {
                        canvasViewPort[5] = (canvasViewPort[5] >= 0) ? 0 : -bottomEndPoint;
                    }

                    var rightEndPoint = canvas.width * (canvasViewPort[0] - 1);
                    if(canvasViewPort[4] >= 0 || -rightEndPoint > canvasViewPort[4]) {
                        canvasViewPort[4] = (canvasViewPort[4] >= 0) ? 0 : -rightEndPoint;
                    }
                }
        }

        let annotation_type_name;
        let annotation_type_color;


        var polygonMode = false;
        var lineMode = false;
        var activeLine = false;
        var polygonPoints =[];
        var polylinePoints =[];
        var indexPoint = 0;
        var polyId = 0;




        function load() {

            //si para esta imagen había anotaciones hechas por el usuario logueado las cargamos
            {% if tag_image is not None %}
                {% for it in tag_image.individual_tags.all %}
                    var annotation_type_color = '{{ it.type.color }}';
                    var annotation_type_name = '{{ it.type.name }}';
                    {% if it.type.primitive == "Point" %}
                         x_absolute = {{ it.individualtagpoint.x }};
                         y_absolute = {{ it.individualtagpoint.y }};

                         x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                         y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;

                            var point = new fabric.Circle({
                                radius: 2,
                                fill: annotation_type_color,
                                left: x_relative,
                                top: y_relative,
                                name: annotation_type_name,
                                selectable: false,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                canvas_width: canvas.width
                            });

                            point.scaleX = scaleX;
                            point.scaleY = scaleY;
                            canvas.add(point);
                    {% elif it.type.primitive == "Box" %}
                        x_absolute = {{ it.individualtagbox.x_top_left }};
                        y_absolute = {{ it.individualtagbox.y_top_left }};
                        width_box = {{ it.individualtagbox.width }};
                        height_box = {{ it.individualtagbox.height }};

                        x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                        y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;
                        w_relative = (width_box * canvas.width)/canvas.backgroundImage.width;
                        h_relative = (height_box * canvas.width)/canvas.backgroundImage.width;

                        let rect = new fabric.Rect({
                            left: x_relative,
                            top: y_relative,
                            name: annotation_type_name,
                            width: w_relative,
                            height: h_relative,
                            selectable: false,
                            lockMovementX: false,
                            lockMovementY: false,
                            lockScalingX: false,
                            lockScalingY: false,
                            hasRotatingPoint: false,
                            fill: false,
                            stroke: annotation_type_color,
                            strokeWidth: 1.5,
                            strokeUniform: true,
                            canvas_width: canvas.width
                        });
                        canvas.add(rect);
                    {% elif it.type.primitive == 'Polygon' %}
                        var polyId = {{ it.individualtagcurve.id }};
                        var polyPoints = [];
                        var index = 0;

                        {% for p in it.individualtagcurve.points %}
                            x_absolute = {{ p.x }};
                            y_absolute = {{ p.y }};

                            x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                            y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;

                            var circle = new fabric.Circle({
                                radius: 2,
                                fill: annotation_type_color,
                                left: x_relative,
                                top: y_relative,
                                name: annotation_type_name,
                                selectable: true,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                originX:'center',
                                originY: 'center',
                                polyId: polyId,
                                id: index,
                                padding:10
                            });
                            circle.scaleX = scaleX;
                            circle.scaleY = scaleY;
                            canvas.add(circle);
                            canvas.bringToFront(circle);
                            polyPoints.push({x:x_relative, y:y_relative, id: index, polyId: polyId});
                            index++;
                        {% endfor %}
                        var polygon = new fabric.Polygon(polyPoints,{
                            name: annotation_type_name,
                            fill: annotation_type_color,
                            stroke: annotation_type_color,
                            strokeWidth: 1.5,
                            opacity: 0.2,
                            hasControls: false,
                            hasBorders: false,
                            selectable: false,
                            lockMovementX: true,
                            lockMovementY: true,
                            lockScalingX: true,
                            lockScalingY: true,
                            objectCaching:false,
                            strokeUniform: true,
                            polyId: polyId,
                            canvas_width: canvas.width
                        });
                        canvas.add(polygon);
                    {% elif it.type.primitive == 'Curve' %}
                        var polyId = {{ it.individualtagcurve.id }};
                        var polyPoints = [];
                        var index = 0;

                        {% for p in it.individualtagcurve.points %}
                            x_absolute = {{ p.x }};
                            y_absolute = {{ p.y }};

                            x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                            y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;

                            var circle = new fabric.Circle({
                                radius: 2,
                                fill: annotation_type_color,
                                top: y_relative,
                                left: x_relative,
                                name: annotation_type_name,
                                selectable: false,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                polyId: polyId,
                                id:index,
                                originX:'center',
                                originY:'center',
                                padding:10

                            });
                            circle.scaleX = scaleX;
                            circle.scaleY = scaleY;
                            canvas.add(circle);
                            canvas.bringToFront(circle);
                            polyPoints.push({x:x_relative, y:y_relative, id: index, polyId: polyId});
                            index++;
                        {% endfor %}
                        var polyline = new fabric.Polyline(polyPoints,{
                            name: annotation_type_name,
                            stroke: annotation_type_color,
                            strokeWidth: 1.5,
                            fill: false,
                            selectable: false,
                            objectCaching:false,
                            strokeUniform: true,
                            lockMovementX: true,
                            lockMovementY: true,
                            lockScalingX: true,
                            lockScalingY: true,
                            polyId: polyId,
                            canvas_width: canvas.width
                        });
                        canvas.add(polyline);
                    {% endif %}
                {% endfor %}
                canvas.renderAll();
            {% endif %}
        }


        function removeEvents() {
            canvas.isDrawingMode = false;
            canvas.selection = false;
            canvas.off('mouse:move', move_panning);
            //EVENTOS TÁCTILES
            container.removeEventListener('touchstart', touchStartPoint);
            container.removeEventListener('touchstart', touchStartBox);
            container.removeEventListener('touchend', touchEnd);
            container.removeEventListener('touchmove', touchMoveBox);

            container.removeEventListener('touchstart', touchStartPolygon);
            container.removeEventListener('touchstart', touchStartCurve);

            //EVENTOS MOUSE
            container.removeEventListener('mousedown', touchStartPoint);
            container.removeEventListener('mousedown', touchStartBox);
            container.removeEventListener('mouseup', touchEnd);
            container.removeEventListener('mousemove', touchMoveBox);

            container.removeEventListener('mousedown', touchStartPolygon);
            container.removeEventListener('mousedown', touchStartCurve);
        }
        function touchStartPoint(evt) {
            if ((evt.type == 'touchstart' && evt.touches[0].touchType === "stylus") || evt.type == 'mousedown'){
                pointerdown = true;
                var pointer = canvas.getPointer(evt.e);
                pos_x = pointer.x;
                pos_y = pointer.y;
                var point = new fabric.Circle({
                    radius: 2,
                    fill: color_tag,
                    top: pos_y,
                    left: pos_x,
                    name: name_tag,
                    selectable: false,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: true,
                    lockScalingY: true,
                    hasRotatingPoint: false,
                    originX: 'center',
                    originY: 'center',
                    canvas_width: canvas.width
                });

                    point.scaleX = scaleX;
                    point.scaleY = scaleY;
                    console.log(point.left, " - ", point.top);


                canvas.add(point);
                //canvas.renderAll();

            }
        }
        function point(name_point, color_point) {
            pointerdown = false;
            name_tag = name_point;
            color_tag = color_point;
            removeEvents();
            container.addEventListener('touchstart', touchStartPoint);
            container.addEventListener('touchend', touchEnd);
            //EVENTOS MOUSE
            container.addEventListener('mousedown', touchStartPoint);
            container.addEventListener('mouseup', touchEnd);
        }
        function touchStartBox(evt) {
            if (evt.type === 'mousedown' || (window.TouchEvent && evt.touches[0].touchType === "stylus")) {
                pointerdown = true;
                var pointer = canvas.getPointer(evt.e);
                pos_x = pointer.x; //posicion inicial
                pos_y = pointer.y;
                var pointer = canvas.getPointer(evt.e);
                rect = new fabric.Rect({
                    left: pos_x,
                    top: pos_y,
                    name: name_tag,
                    width: pointer.x - pos_x,
                    height: pointer.y - pos_y,
                    selectable: false,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: true,
                    lockScalingY: true,
                    hasRotatingPoint: false,
                    fill: false,
                    stroke: color_tag,
                    strokeWidth: stroke,
                    strokeUniform: true,
                    canvas_width: canvas.width
                });
                canvas.add(rect);
            }
        }
        function touchMoveBox(evt) {
            if (evt.type === 'mousemove' || (window.TouchEvent && evt.touches[0].touchType === "stylus")) {
                if (!pointerdown) return;
                var pointer = canvas.getPointer(evt.e);
                if (pos_x > pointer.x) {
                    rect.set({
                        left: Math.abs(pointer.x)
                    });
                }
                if (pos_y > pointer.y) {
                    rect.set({
                        top: Math.abs(pointer.y)
                    });
                }
                rect.set({
                    width: Math.abs(pos_x - pointer.x)
                });
                rect.set({
                    height: Math.abs(pos_y - pointer.y)
                });
                canvas.renderAll();
            }
        }
        function touchEnd(evt) {
            if (evt.type === 'mouseup' || (window.TouchEvent && evt.touches[0].touchType === "stylus")) {
                pointerdown = false;
                canvas.renderAll();
            }
        }
        function box(name_box, color_box) {
            pointerdown = false;
            name_tag = name_box;
            color_tag = color_box;
            removeEvents();
            //EVENTOS TÁCTILES
            container.addEventListener('touchstart', touchStartBox);
            container.addEventListener('touchmove', touchMoveBox);
            container.addEventListener('touchend', touchEnd);
            //EVENTOS MOUSE
            container.addEventListener('mousedown', touchStartBox);
            container.addEventListener('mousemove', touchMoveBox);
            container.addEventListener('mouseup', touchEnd);
        }
        function polygon(name_polygon, color_polygon){

            if(polygonMode == true){
/*
                var polygon = new fabric.Polygon(polygonPoints, {
                 selectable: false,
                 objectCaching: false,
                 fill: color_tag,
                 opacity:0.3,
                 hasBorders: false,
                 hasControls: false,
                 name: name_tag,
                 polyId: polyId,
                 lockMovementX: true,
                 lockMovementY: true,
                 lockScalingX: true,
                 lockScalingY: true,
                 strokeUniform: true,
                 canvas_width: canvas.width

             });
              canvas.add(polygon);
              canvas.renderAll();*/

                polygonMode = false;
                polygonPoints = [];
                indexPoint = 0;
            }
            activeLine = false;
            polygonMode = true;
            pointerdown = false;
            name_tag = name_polygon;
            color_tag = color_polygon;
            removeEvents();
            var random = Math.floor(Math.random() * (999999 - 99 + 1)) + 99;
            polyId = new Date().getTime() + random;

            container.addEventListener('mousedown', touchStartPolygon);
            container.addEventListener('touchstart', touchStartPolygon);
        }
        function curved(name_curve, color_curve){

            if(lineMode == true){
                lineMode = false;
                polylinePoints = [];
                indexPoint = 0;
            }
            activeLine = false;
            lineMode = true;
            pointerdown = false;
            name_tag = name_curve;
            color_tag = color_curve;
            removeEvents();

            var random = Math.floor(Math.random() * (999999 - 99 + 1)) + 99;
            polyId = new Date().getTime() + random;

            container.addEventListener('mousedown', touchStartCurve);
            container.addEventListener('touchstart', touchStartCurve);


        }
        function touchStartCurve(evt) {
             if (evt.type === 'mousedown' || (window.TouchEvent && evt.touches[0].touchType === "stylus")) {
                 if (lineMode) {
                    var pointer = canvas.getPointer(evt.e);
                    pos_x = pointer.x;
                    pos_y = pointer.y;

                    var circle = new fabric.Circle({
                        radius: 2,
                        fill: color_tag,
                        name: name_tag,
                        left: pos_x,
                        top: pos_y,
                        selectable: false,
                        hasBorders: false,
                        hasControls: false,
                        hasRotatingPoint:false,
                        lockMovementX: false,
                        lockMovementY: false,
                        lockScalingX: false,
                        lockScalingY: false,
                        objectCaching:false,
                        originX: 'center',
                        originY: 'center',
                        id: indexPoint,
                        polyId: polyId,
                        padding:10
                    });
                    circle.scaleX = scaleX;
                    circle.scaleY = scaleY;
                    canvas.add(circle);
                    canvas.bringToFront(circle);

                    if(activeLine){
                        var pos = canvas.getPointer(evt.e);
                        var polylinePoints = activeLine.get("points");
                        polylinePoints.push({
                            x: pos.x,
                            y: pos.y,
                            polyId: polyId,
                            id: indexPoint
                        });
                        var polyline = new fabric.Polyline(polylinePoints, {
                            selectable: false,
                            objectCaching: false,
                            strokeWidth: stroke,
                            strokeUniform: true,
                            name: name_tag,
                            stroke: color_tag,
                            fill: false,
                            hasBorders: false,
                            hasControls: false,
                            polyId: polyId,
                            canvas_width: canvas.width
                        });
                        canvas.remove(activeLine);
                        canvas.add(polyline);
                        activeLine = polyline;
                    }
                    else{
                        var polylinePoints = [{x:pos_x,y:pos_y,polyId:polyId,id:indexPoint}];
                        polyline = new fabric.Polyline(polylinePoints);
                        activeLine = polyline;
                        canvas.add(polyline);
                    }
                    indexPoint++;
                    canvas.selection = false;

                 }
             }
        }

        function touchStartPolygon(evt) {
            if (evt.type === 'mousedown' || (window.TouchEvent && evt.touches[0].touchType === "stylus")) {
                if (polygonMode) {
                    var pointer = canvas.getPointer(evt.e);
                    pos_x = pointer.x;
                    pos_y = pointer.y;


                    var circle = new fabric.Circle({
                        radius: 2,
                        fill: color_tag,
                        left: pos_x,
                        top: pos_y,
                        name: name_tag,
                        originX: 'center',
                        originY: 'center',
                        selectable: false,
                        hasBorders: false,
                        hasControls: false,
                        id: indexPoint,
                        polyId: polyId,
                        padding:10
                    });

                    circle.scaleX = scaleX;
                    circle.scaleY = scaleY;
                    canvas.add(circle);
                    canvas.bringToFront(circle);

                    if(activeLine){
                        var pos = canvas.getPointer(evt.e);
                        var polygonPoints = activeLine.get("points");
                        polygonPoints.push({
                            x: pos.x,
                            y: pos.y,
                            polyId: polyId,
                            id: indexPoint
                        });
                        var polygon = new fabric.Polygon(polygonPoints, {
                             selectable: false,
                             objectCaching: false,
                             fill: color_tag,
                             stroke: color_tag,
                             strokeWidth: stroke,
                             opacity:0.2,
                             hasBorders: false,
                             hasControls: false,
                             name: name_tag,
                             polyId: polyId,
                             lockMovementX: true,
                             lockMovementY: true,
                             lockScalingX: true,
                             lockScalingY: true,
                             strokeUniform: true,
                             canvas_width: canvas.width
                         });
                        canvas.remove(activeLine);
                        canvas.add(polygon);
                        activeLine = polygon;
                    }
                    else{
                        var polygonPoints = [{x:pos_x,y:pos_y,polyId:polyId,id:indexPoint}];
                        polygon = new fabric.Polyline(polygonPoints);
                        activeLine = polygon;
                        canvas.add(polygon);
                    }

                    indexPoint++;
                    canvas.selection = false;
                }
            }
        }


        canvas.on('object:moving', function(evt){
            if(evt.target.type == 'circle'){
                canvas.getObjects().filter(function(obj){
                   if((obj.type == 'polygon' || obj.type == 'polyline') && obj.polyId == evt.target.polyId){
                        obj.points[evt.target.id] = {x: evt.target.left, y: evt.target.top, polyId:obj.polyId, id:evt.target.id};
                   }
                });
            }
            canvas.renderAll();
        });



        canvas.on('object:modified', function(evt) {
            if(evt.target.type == 'activeSelection') {
                evt.target.getObjects().filter(function(obj){
                    if(obj.type == 'circle'){
                        canvas.remove(obj);
                    }
                    if(obj.type == 'polygon' || obj.type == 'polyline') {

                        var matrix = obj.calcTransformMatrix();

                        var translatedPoints = obj.points.map(function (p) {
                            return {
                                x: p.x - obj.pathOffset.x + matrix[4],
                                y: p.y - obj.pathOffset.y + matrix[5],
                                id: p.id,
                                polyId: p.polyId
                            };
                        });

                        var id = obj.polyId;
                        var color = obj.fill;
                        var name = obj.name;


                        if(obj.type == 'polygon'){
                            var poly = new fabric.Polygon(translatedPoints, {
                                selectable: false,
                                objectCaching: false,
                                fill: color,
                                stroke: color,
                                strokeWidth: stroke,
                                opacity: 0.2,
                                hasBorders: false,
                                hasControls: false,
                                name: name,
                                polyId: id,
                                lockMovementX: true,
                                lockMovementY: true,
                                lockScalingX: true,
                                lockScalingY: true,
                                strokeUniform: true,
                                canvas_width: canvas.width
                            });

                        }else if(obj.type == 'polyline'){
                            var poly = new fabric.Polyline(translatedPoints, {
                                 name: name,
                                stroke: color,
                                strokeWidth: stroke,
                                fill: false,
                                selectable: false,
                                objectCaching:false,
                                strokeUniform: true,
                                lockMovementX: true,
                                lockMovementY: true,
                                lockScalingX: true,
                                lockScalingY: true,
                                polyId: polyId,
                                canvas_width: canvas.width
                            });
                        }
                        canvas.remove(obj);
                        canvas.add(poly);

                        translatedPoints.map(function(p){
                            var circle = new fabric.Circle({
                                radius: 2,
                                fill: color,
                                left: p.x,
                                top: p.y,
                                name: name,
                                selectable: true,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                originX:'center',
                                originY: 'center',
                                polyId: id,
                                id: p.id,
                                padding:10
                            });
                            circle.scaleX = scaleX;
                            circle.scaleY = scaleY;
                            canvas.add(circle);
                            canvas.bringToFront(circle);

                        });

                        canvas.renderAll();
                    }

                });

            }
            canvas.renderAll();
        });


        canvas.on('before:selection:cleared', function(){
            document.getElementById("button-delete").disabled = true;
        });


        canvas.on('object:selected', function(evt){

            canvas.discardActiveObject();
            document.getElementById("button-delete").disabled = false;

            if(evt.target.type == 'polygon' || evt.target.type == 'polyline'){
                console.log(evt.target.scaleX);

                var sel = new fabric.ActiveSelection(canvas.getObjects().filter(function(obj){
                    if(obj.type === 'circle' && obj.polyId == evt.target.polyId){
                        return obj.set('active', true);
                    }
                    else if(obj == evt.target){
                        return obj.set('active', true);
                    }
                }), {
                    canvas:canvas,
                    hasControls: false,
                    selectable:false,
                    strokeUniform: true

                });
                canvas.setActiveObject(sel);
                canvas.renderAll();
            }
        });

        function select_tag() {
            panning = false;
            removeEvents();

            canvas.forEachObject(function (obj) {
                obj.selectable = true;
            });
            canvas.selection = true;
            canvas.renderAll();
        }
        function delete_tag() {
            canvas.getActiveObjects().forEach((obj) => {
                canvas.remove(obj);
            });
            canvas.discardActiveObject().renderAll()
        }
        function save(){
            canvas.renderAll();
            console.log(canvas);

            var URL = "{% url 'save_tags' id_exp=exp.id id_image=image.id %}";
            var data = JSON.stringify(canvas.toDatalessJSON(['name', 'top', 'left', 'fill', 'stroke', 'polyId', 'id', 'canvas_width']));
            $.post(URL, {'canvas_data': data});
            document.getElementById("text-alert").innerText = gettext("saved");
            $('.alert').show();
        }
        function validate() {
            {% if tag_image is not None %}
                var URL = "{% url 'validate' id_exp=exp.id id_image=image.id id_user=tag_image.user.id %}";
                var data = JSON.stringify(canvas.toDatalessJSON(['name', 'top', 'left', 'fill', 'stroke', 'polyId', 'id', 'canvas_width']));
                $.post(URL, {'canvas_data': data});
                document.getElementById("text-alert").innerText = gettext("validated");
                $('.alert').show();
            {% endif %}
        }
    </script>
{% endblock %}




{% extends 'base.html' %}
{% csrf_token %}
{% load static %}
{% load i18n %}
{% block content %}

    <style>
    .main-section .container{
        padding-left: 0px;
        padding-right: 0px;
        margin-right: 0px;
        margin-left: 0px;
        max-width: 100%;
    }

    .main-section .container .main{
        margin-top: 20px;
        margin-bottom: 0px;
    }

    #back{
        margin-left: 75px;
    }



.wrapper {
    display: flex;
    width: 100%;
    align-items: stretch;
}

#sidebar {
    min-width: 300px;
    max-width: 300px;
    transition: all 0.3s;
    text-align: center;
    height: auto;
}

#sidebar.active {
    margin-left: -300px;
}

.table-tags {
    width: 50%;
    margin: 0px auto;
    float: none;
}


#content {
    padding: 20px;
    width: 100%;
    transition: all 0.3s;
}

#sidebarCollapse{
    padding:0px;
    margin-left: 5px;
    background-color: #bfbfbf;
}

@media (max-width: 768px) {
    #sidebar {
        margin-left: -250px;
    }
    #sidebar.active {
        margin-left: 0;
    }
    #sidebarCollapse span {
        display: none;
    }
}


</style>

    <a id="back" href="{% url 'images_experiment' id=exp.id %}"><i class="fas fa-arrow-left"></i> {% trans "BACK" %}</a>
    <div class="main">
        <div class="alert-annotate">
            <div class="alert alert-success alert-dismissible fade show" style="margin-left: 75px; margin-right: 75px;" role="alert">
                {% trans "Annotations" %} <strong id="text-alert"></strong>!
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        </div>

    <div class="wrapper">
        <div id="sidebar">
                        <table class="table text-center table-tags">
                            <caption>{% trans "Defined annotations" %}
                            </caption>
                            <tbody>
                            {% for at in annotation_types %}
                                <tr>
                                    {% if at.primitive == "Point" %}
                                        <td><a href="#" onclick="point('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                        <td><i class="fas fa-circle" style="color: {{ at.color }}"></i></td>

                                    {% elif at.primitive == "Box" %}
                                        <td><a href="#" onclick="box('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                        <td><i class="far fa-square" style="color: {{ at.color }}"></i></td>

                                    {% elif at.primitive == "Polygon" %}
                                    <td><a href="#" onclick="polygon('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                    <td><i class="fas fa-draw-polygon" style="color: {{ at.color }}"></i></td>

                                    {% elif at.primitive == "Curve" %}
                                    <td><a href="#" onclick="curved('{{ at.name }}','{{ at.color }}');">{{ at.name }}</a></td>
                                    <td><i class="fas fa-signature" style="color: {{ at.color }}"></i></td>
                                    {% endif %}
                                </tr>
                            {% endfor %}
                            </tbody>
                        </table><br>
                        <button class="btn btn-secondary w-50" title="{% trans "Save tags" %}" onclick="save();"> {% trans "Save" %}</button>
                        {% if user.is_authenticated and user.is_superuser %}
                            {% if tag_image and not tag_image.check_by and user != tag_image.user %}
                                <br><br><button class="btn btn-success" title="{% trans 'Validate tags and save changes' %}" onclick="validate();">{% trans "Validate and Save" %}</button>
                            {% elif tag_image and tag_image.check_by and user != tag_image.user %}
                                <br><br><button class="btn btn-danger" title="{% trans 'Invalidate tags and save changes' %}" onclick="invalidate();">{% trans "Invalidate and Save" %} </button>
                            {% endif %}

                        {% elif user.is_authenticated and user.is_staff %}
                            {% if tag_image and not tag_image.check_by and not tag_image.user.is_staff %}
                                <br><br><button class="btn btn-success" title="{% trans 'Validate tags and save changes' %}" onclick="validate();">{% trans "Validate and Save" %}</button>
                            {% elif tag_image and tag_image.check_by and not tag_image.user.is_staff %}
                                <br><br><button class="btn btn-danger" title="{% trans 'Invalidate tags and save changes' %}" onclick="invalidate();">{% trans "Invalidate and Save" %} </button>
                            {% endif %}
                        {% endif %}

        </div>

    <button type="button" id="sidebarCollapse" class="btn">
        <i class="fas fa-angle-double-left"></i>
    </button>

        <div id="content">
                        {% if tag_image is not None %}
                            <p><i class="fas fa-edit"></i> {% trans "Annotated by" %} <b>{{ tag_image.user }}</b></p>
                        {% else %}
                            <p>{% trans "There isn't any annotation yet" %}</p>
                        {% endif %}


        <button class="btn btn-secondary" title="{% trans 'zoom in' %}" onclick="zoom_in();"><i class="fas fa-search-plus"></i></button>
        <button class="btn btn-secondary" title="{% trans 'zoom out' %}" onclick="zoom_out();"><i class="fas fa-search-minus"></i></button>
        <button class="btn btn-secondary" title="{% trans 'panning' %}" onclick="do_panning();"><i class="far fa-hand-paper"></i></button>
        <button class="btn btn-primary" title="{% trans 'select tags' %}" onclick="select_tag();"><i class="fas fa-mouse-pointer"></i></button>
        <button class="btn btn-danger" id="button-delete" title="{% trans 'delete tags selected' %}" onclick="delete_tag();"><i class="fas fa-trash-alt"></i></button>
         <button class="btn btn-warning float-right" data-toggle="modal" data-target=".bd-example-modal-lg"><i class="fas fa-question"></i></button>

        <div id="container_canvas">
             <canvas id="myCanvas">
            Your browser does not support the HTML5 canvas tag
            </canvas>
        </div>
        </div>
    </div>
    </div>




<div class="modal fade bd-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
        <div class="modal-header">
            <h5 class="modal-title" id="ModalDownloadLongTitle">{% trans "Help" %}</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
            </button>
        </div>
        <div class="modal-body">
          <p>{% trans "Defined annotations" %}</p>
            <p>{% trans "They are the annotations that are defined for this experiment. They are shown by their name and an icon of the type of primitive to be made whose color corresponds to the one defined for the annotation. You can show or hide this panel by pressing the sidebar. To comment to write down click on the name of the annotation and then on the canvas taking into account the following" %}</p>
            <p><i class="fas fa-circle"></i> {% trans "Point type annotation. Press the stylus or mouse on the place where you want to make a point and release" %} </p>
            <p><i class="fas fa-square"></i> {% trans "Box type annotation. Press the stylus or mouse on the place where you want to comment on a box, drag and drop." %}</p>
            <p><i class="fas fa-draw-polygon"></i> {% trans "Polygon type annotation. Repeat the procedure of the point annotation for each vertex of the polygon and it will automatically be formed. To finish the polygon, click on the name of the entry again." %}</p>
            <p><i class="fas fa-signature"></i> {% trans "Curve type annotation. Repeat the point annotation procedure for each vertex of the curve and it will automatically form. To end the curve, click on the name of the entry again." %}</p>
          <hr>
            <p>{% trans "Buttons" %}</p>
            <button class="btn btn-secondary"><i class="fas fa-search-plus"></i></button> {% trans "Zoom on the center of the image" %} <br><br>
            <button class="btn btn-secondary"><i class="fas fa-search-minus"></i></button> {% trans "Undo zoom on the center of the image if it has previously been performed" %}<br><br>
            <button class="btn btn-secondary"><i class="far fa-hand-paper"></i></button> {% trans "Panning over the image if you zoomed in on it" %}<br><br>
            <button class="btn btn-primary"><i class="fas fa-mouse-pointer"></i></button> {% trans "Select tag or tags" %}<br><br>
            <button class="btn btn-danger"><i class="fas fa-trash-alt"></i></button> {% trans "Delete selected tag. Only visible if there is any selected tag. "%}<br><br>
            <button class="btn btn-secondary"> {% trans "Save" %}</button> {% trans "Save the current tags" %}<br><br>
            <button class="btn btn-success">{% trans "Validate and Save" %}</button> {% trans "Validate and save changes. Only visible if you are a expert user. With this buttom you can check the tags made by the rest of the basic users of your team and/or to do changes above their tags. " %}
            <br><br>
            <button class="btn btn-danger">{% trans 'Invalidate and Save'%}</button> {% trans "Invalidate and save changes. Only visible if you are a expert user and other basic user has done tags. With this button you can invalidate something that previosly has been validate. Only if you are admin you can validate the work of a expert user." %}
         <hr>
            <p><i class="fas fa-edit"></i> {% trans "Annotated by" %} : {% trans "The name of the user who made the shown tags" %}</p>
            <hr>
            <p>{% trans "The zoom wheel is avaliable for computer, so you can do zoom with the mouse wheel above the exact point that you want. For touch devices, you can only annotate with a touch pencil. The use of the fingers is only for do zoom above the canvas or panning. " %}</p>
        </div>

    </div>
  </div>
</div>




    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.3/js/materialize.min.js"></script>
    <script src="{% static "js/fabric.js" %}" type="text/javascript"></script>
    <script type="text/javascript" src="{% url 'javascript-catalog' %}"></script>
    <script>
            /**
         *envoltorio del canvas para poder lanzar eventos mediante addEventListener y removerlos con removeEventListener
         */
        let container = document.getElementById("container_canvas");

        /**
         * objeto canvas de fabric
         */
        let canvas = new fabric.Canvas('myCanvas');


        /**
         * Variables de configuración de objetos de fabric
         * */
        fabric.Group.prototype.hasControls = false;
        fabric.Group.prototype.hasBorders = false;
        fabric.Polyline.prototype.hasControls = false;
        fabric.Polyline.prototype.hasBorders = false;
        fabric.Polygon.prototype.hasBorders = false;
        fabric.Object.prototype.hasRotatingPoint = false;
        fabric.Object.NUM_FRACTION_DIGITS = 10;


        /**
         * VARIABLES GLOBALES
         * @param proporcion : proporcion del ancho y el alto de la imagen del canvas
         * @param pointerdown: variable que indica si el puntero está sobre la pantalla
         * @param factorScale: proporción entre el ancho antiguo del canvas y el nuevo que se quiere establecer
         * @param scaleX: proporción de escalado de los objetos para X
         * @param scaleY: proporción de escalado de los objetos para Y
         * @param canvas_width: ancho por defecto del canvas, que siempre será el máximo disponible teniendo en cuenta el tamaño de la ventana
         * @param stroke: ancho de las líneas de los objetos
         * @param currentX : posición X actual en el momento que se hace el zoom táctil
         * @param currentY : posición Y actual en el momento que se hace el zoom táctil
         * @param lastX : posición X en la que se suelta en el momento de hacer el zoom táctil
         * @param lastY : posición Y en la que se suelta en el momento de hacer el zoom táctil
         * @param panning : variable que indica si se está realizando el panning
         * @paran polygonMode : variable que indica si se está realizando un polígono
         * @param lineMode : variable que indica si se está realizando una curva
         * @param activeLine : línea activa de la curva en el momento de dibujarse
         * @param polygonPoints : array de puntos del polígono
         * @param polylinePoints : array de puntos de la curva
         * @param indexPoint :identificador de cada punto de un polígono o curva
         * @param polyId: identificador de cada polígono o curva
         *
        * */
        var proporcion = 1;
        let pointerdown = false;
        let factorScale = 1.0;
        var scaleX = 1.0;
        var scaleY = 1.0;
        var canvas_width = window.innerWidth-380.0;
        var stroke = 1.5;
        var currentX = 0;
        var currentY = 0;
        var lastX = 0;
        var lastY = 0;
        var panning = false;
        var polygonMode = false;
        var lineMode = false;
        var activeLine = false;
        var polygonPoints =[];
        var polylinePoints =[];
        var indexPoint = 0;
        var polyId = 0;



        /**
         * REDIMENSIONADO DE LA VENTANA
         * Se ejecuta cada vez que se redimensiona la ventana actual del navegador para ajustar el canvas al tamaño máximo disponible
         */
        $(window).resize(function(){
            if(document.getElementById("sidebar").classList.contains('active')){
                resizeCanvas(window.innerWidth-50.0);

            }
            else{
                resizeCanvas(window.innerWidth-380.0);
            }
        });

        /**
         * INICIALIZACIÓN DEL CANVAS
         * Se establecen las dimensiones del canvas con respecto a la imagen que se está cargando sobre él, manteniendo su proporción original,
         * y se cargan las anotaciones ya realizadas mediante una llamada a la función load()
         */
        fabric.Image.fromURL('/{{ image.path }}/{{ image.name_unique }}', function (img) {
                proporcion = img.width/img.height;
                canvas.setWidth(window.innerWidth-380.0);
                canvas.setHeight((window.innerWidth-380.0)/proporcion);
                img.scaleToWidth(canvas.getWidth(), canvas.renderAll.bind(canvas));
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));

                load();
                 document.getElementById("button-delete").disabled = true;

        });

        /**
         * REESCALADO DEL CANVAS
         * Realiza el reescalado de la imagen y de todos los objetos dibujados, adaptándolo siempre al máximo ancho disponible
         * pero manteniendo la proporción original de la imagen
         *
         * @param newWidth: nuevo ancho que va a tomar el canvas tras el proceso de reescalado
         */
        function resizeCanvas(newWidth){

            if (canvas.getWidth() != newWidth){
                factorScale = newWidth/canvas.getWidth();
                canvas.setWidth(canvas.getWidth()*factorScale);
                canvas_width = canvas.width;
                canvas.setHeight(canvas.getHeight()*factorScale);

                canvas.discardActiveObject();


                canvas.getObjects().forEach((obj) => {
                        obj.scaleX = obj.scaleX * factorScale;
                        obj.scaleY = obj.scaleY * factorScale;
                        scaleX = obj.scaleX;
                        scaleY = obj.scaleY;
                        obj.left = obj.left * factorScale;
                        obj.top = obj.top * factorScale;
                        obj.setCoords();
                });


                canvas.backgroundImage.scaleToWidth(canvas.getWidth(), canvas.renderAll.bind(canvas));

            }
        }


        /**
         * MOSTRAR/OCULTAR PANEL DE ANOTACIONES
         * Se ejecuta cada vez que se abre o se cierra el panel lateral de anotaciones, reescalando el canvas con el tamaño actual de la ventana
         */
        $(document).ready(function () {
            $('#sidebarCollapse').on('click', function () {
                $('#sidebar').toggleClass('active');
                $('.fa-angle-double-left').toggleClass('fa-angle-double-right');
                if (canvas.width == window.innerWidth-50.0){
                    resizeCanvas(window.innerWidth-380.0);
                }
                else{
                    resizeCanvas(window.innerWidth-50.0);
                }
            });
        });


        /**
         * ZOOM IN
         * Realiza el zoom sobre el canvas y escala los objetos que hay en él así como los que se vayan a dibujar
         *
         * @param pos_x : coordenada X sobre la que se va a realizar el zoom. Si la función no recibe ninguna, por defecto toma el valor
         * de la mitad del ancho del canvas.
         * @param pos_y : coordenada Y sobre la que se va a realizar el zoom. Si la función no recibe ninguna, por defecto toma el valor
         * de la mitad del alto del canvas.
         */
        function zoom_in(pos_x, pos_y){

            if(pos_x && pos_y){
                canvas.zoomToPoint(new fabric.Point(pos_x, pos_y), canvas.getZoom() * 1.1);
            }else{
                canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), canvas.getZoom() * 1.1);
            }
            var scale = 1 / canvas.getZoom();
            canvas.forEachObject(function(obj){
                if(obj.type == 'circle'){
                    obj.scaleX = scale * 1.1;
                    scaleX = obj.scaleX;
                    obj.scaleY = scale  * 1.1;
                    scaleY = obj.scaleY;
                }
                if(obj.type == 'rect' || obj.type == 'polyline' || obj.type == 'polygon'){
                     obj.strokeWidth = 1.5*scale;
                     stroke = obj.strokeWidth;

                }
            });
        }


        /**
         * ZOOM OUT
         *
         * Aleja el zoom sobre el canvas y escala los objetos que hay en él así como los que se vayan a dibujar
         *
         * @param pos_x : coordenada X sobre la que se va a realizar el zoom. Si la función no recibe ninguna, por defecto toma el valor
         * de la mitad del ancho del canvas.
         * @param pos_y : coordenada Y sobre la que se va a realizar el zoom. Si la función no recibe ninguna, por defecto toma el valor
         * de la mitad del alto del canvas.
         */
        function zoom_out(pos_x,pos_y){
            if (canvas.getZoom()>1){
                if(pos_x && pos_y){
                    canvas.zoomToPoint(new fabric.Point(pos_x, pos_y), canvas.getZoom() / 1.1);
                }else{
                    canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), canvas.getZoom() / 1.1);
                }
                var scale = 1 / canvas.getZoom();
                canvas.forEachObject(function(obj){
                    if(obj.type == 'circle') {
                        obj.scaleX = scale / 1.1;
                        scaleX = obj.scaleX;
                        obj.scaleY = scale / 1.1;
                        scaleY = obj.scaleY;
                    }
                    if(obj.type == 'rect' || obj.type == 'polyline' || obj.type == 'polygon'){
                        obj.strokeWidth = 1.5*scale;
                        stroke = obj.strokeWidth;
                    }
                });
            }
        }


        canvas.on({
        /**
        ZOOM TÁCTIL
        * Solo para dispositivos táctiles y cuya interacción se haga mediante dos dedos
         * */
        'touch:gesture': function(e) {
            if (e.e.touches && e.e.touches.length == 2 && e.e.touches[0].touchType === "direct") {
                panning = false;
                var point = new fabric.Point(e.self.x, e.self.y);
                if (e.self.state == "start") {
                    zoomStartScale = canvas.getZoom();
                }
                var delta = zoomStartScale * e.self.scale;

                if (delta > 10) delta = 10;

                if (delta < 1) {
                    delta = 1;
                    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
                }
                canvas.zoomToPoint(point, delta);



                panning = true;
            }
        },

        /**
        PANNING TÁCTIL
        Solo para dispositivos táctiles y para interaccionar con el dedo. Con el lápiz táctil no se permite realizar panning.
        * */
        'touch:drag': function(e) {
            canvas.selection = false;
            if (panning && e.e.touches && e.e.touches.length == 1 && e.e.touches[0].touchType === "direct") {
                canvas.selection = false;

                currentX = e.self.x;
                currentY = e.self.y;
                xChange = currentX - lastX;
                yChange = currentY - lastY;

                if( (Math.abs(currentX - lastX) <= 50) && (Math.abs(currentY - lastY) <= 50)) {
                    var delta = new fabric.Point(xChange, yChange);
                    canvas.relativePan(delta);
                }

                lastX = e.self.x;
                lastY = e.self.y;
                var canvasViewPort = canvas.viewportTransform;

                var bottomEndPoint = canvas.height * (canvasViewPort[0] - 1);
                if(canvasViewPort[5] >= 0 || -bottomEndPoint > canvasViewPort[5]) {
                    canvasViewPort[5] = (canvasViewPort[5] >= 0) ? 0 : -bottomEndPoint;
                }

                var rightEndPoint = canvas.width * (canvasViewPort[0] - 1);
                if(canvasViewPort[4] >= 0 || -rightEndPoint > canvasViewPort[4]) {
                    canvasViewPort[4] = (canvasViewPort[4] >= 0) ? 0 : -rightEndPoint;
                }
            }
        },

        /**
        MOVIMIENTO DE UN OBJETO
        Es la función encargada del movimiento de los puntos de un polígono o curva, por lo tanto solo se ejecuta cuando el objecto a mover
        es dicho punto.
        * */
        'object:moving': function(evt){
            if(evt.target.type == 'circle'){
                canvas.getObjects().filter(function(obj){
                   if((obj.type == 'polygon' || obj.type == 'polyline') && (obj.polyId == evt.target.polyId)){
                        obj.points[evt.target.id] = {x: evt.target.left, y: evt.target.top, polyId:obj.polyId, id:evt.target.id};
                   }
                });
            }
            canvas.renderAll();
        },

        /**
        * MOVIMIENTO DE UN POLÍGONO
        * Se ejecuta cuando un polígono (junto con sus puntos) es desplazado
         * */
        'object:modified': function(evt){
            if(evt.target.type == 'activeSelection') {
                evt.target.getObjects().filter(function(obj){
                    if(obj.type == 'circle'){
                        canvas.remove(obj);
                    }
                    if(obj.type == 'polygon') { // añadir || obj.type == 'polyline'
                        var matrix = obj.calcTransformMatrix();

                        var translatedPoints = obj.points.map(function (p) {
                            return {
                                x: p.x - obj.pathOffset.x + matrix[4],
                                y: p.y - obj.pathOffset.y + matrix[5],
                                id: p.id,
                                polyId: p.polyId
                            };
                        });

                        var id = obj.polyId;
                        var color = obj.fill;
                        var name = obj.name;

                        /*
                        if(obj.type == 'polyline'){
                            var polyline = new fabric.Polyline(translatedPoints,{
                            name: name,
                            stroke: color,
                            strokeWidth: 1.5,
                            fill: false,
                            selectable: false,
                            objectCaching:false,
                            strokeUniform: true,
                            lockMovementX: true,
                            lockMovementY: true,
                            lockScalingX: true,
                            lockScalingY: true,
                            polyId: id,
                            canvas_width: canvas.width
                        });
                            canvas.remove(obj);
                            canvas.add(polyline);
                        }*/

                        if(obj.type == 'polygon') {

                            var poly = new fabric.Polygon(translatedPoints, {
                                selectable: false,
                                objectCaching: false,
                                fill: color,
                                stroke: color,
                                strokeWidth: stroke,
                                opacity: 0.2,
                                hasBorders: false,
                                hasControls: false,
                                name: name,
                                polyId: id,
                                lockMovementX: true,
                                lockMovementY: true,
                                lockScalingX: true,
                                lockScalingY: true,
                                strokeUniform: true,
                                canvas_width: canvas.width
                            });

                            canvas.remove(obj);
                            canvas.add(poly);
                        }

                        translatedPoints.map(function (p) {
                                var circle = new fabric.Circle({
                                    radius: 2,
                                    fill: color,
                                    left: p.x,
                                    top: p.y,
                                    name: name,
                                    selectable: true,
                                    lockMovementX: false,
                                    lockMovementY: false,
                                    lockScalingX: true,
                                    lockScalingY: true,
                                    hasRotatingPoint: false,
                                    originX: 'center',
                                    originY: 'center',
                                    polyId: id,
                                    id: p.id,
                                    padding: 10
                                });
                                circle.scaleX = scaleX;
                                circle.scaleY = scaleY;
                                canvas.add(circle);
                                canvas.bringToFront(circle);
                            });
                        canvas.renderAll();
                    }
                });

            }
            canvas.renderAll();
        },

        /**
         * SELECCIÓN DE UN POLÍGONO O CURVA
         * Se encarga de seleccionar de forma solidaria tanto el polígono/curva como los puntos que lo forman
         */
        'object:selected': function(evt){

           if(evt.target.type == 'polygon' || evt.target.type == 'polyline'){
                canvas.discardActiveObject();

                var sel = new fabric.ActiveSelection(canvas.getObjects().filter(function(obj){
                    if(obj.type === 'circle' && obj.polyId == evt.target.polyId){
                        return obj.set('active', true);
                    }
                    else if(obj == evt.target){
                        return obj.set('active', true);
                    }
                }), {
                    canvas:canvas,
                    hasControls: false,
                    hasBorders: false,
                    strokeUniform: true

                });
                canvas.setActiveObject(sel);
                document.getElementById("button-delete").disabled = false;
                if(evt.target.type == 'polyline'){
                    sel.lockMovementY = true;
                    sel.lockMovementX = true;
                }
            }
        },

        /**
         * DESACTIVAR BOTÓN DE BORRADO
         * Cuando no hay objetos seleccionados, el botón de borrado de anotaciones es desactivado
          */
        'before:selection:cleared': function(){
        document.getElementById("button-delete").disabled = true;
        },

        /**
         * ZOOM WHEEL
         * Funciona solo cuando hay un ratón conectado en el dispositivo. Se realiza zoom mediante la rueda del ratón
         * sobre el punto en el que se coloca el puntero
         */
        'mouse:wheel': function(evt){
            var delta = Math.sign(evt.e.deltaY);
              var pointer = canvas.getPointer(evt.e);
              pos_x = pointer.x;
              pos_y = pointer.y;
              if (delta == -1){ //zoom in
                    zoom_in(pos_x, pos_y);
                }else if(delta == 1){ //zoom out
                    zoom_out(pos_x, pos_y);
                }
              evt.e.preventDefault();
              evt.e.stopPropagation();
        }
    });


        /**
         * PANNING MOUSE
         * Funciones relacionadas con la realización de panning mediante un evento de ratón
         * */
        function panningTrue(){
            panning = true;
        }
        function panningFalse(){
            panning = false;
        }
        function do_panning(){
            removeEvents();

            canvas.on('mouse:down', panningTrue);
            canvas.on('mouse:up', panningFalse);
            canvas.on('mouse:move', movePanning);

        }
        function movePanning(evt){

            if (panning && evt) {
                evt.e.preventDefault();

                var delta = new fabric.Point(evt.e.movementX, evt.e.movementY);
                canvas.relativePan(delta);

                var canvasViewPort = canvas.viewportTransform;

                var bottomEndPoint = canvas.height * (canvasViewPort[0] - 1);
                if(canvasViewPort[5] >= 0 || -bottomEndPoint > canvasViewPort[5]) {
                    canvasViewPort[5] = (canvasViewPort[5] >= 0) ? 0 : -bottomEndPoint;
                }

                var rightEndPoint = canvas.width * (canvasViewPort[0] - 1);
                if(canvasViewPort[4] >= 0 || -rightEndPoint > canvasViewPort[4]) {
                    canvasViewPort[4] = (canvasViewPort[4] >= 0) ? 0 : -rightEndPoint;
                }
            }
        }


        /**
         * CARGA DE ANOTACIONES
         * Carga sobre el canvas todas las anotaciones realizadas sobre la imagen y almacenadas en la base de datos
         */
        function load() {
           // {% if tag_image is not None %}
                {% for it in tag_image.individual_tags.all %}
                    var annotation_type_color = '{{ it.type.color }}';
                    var annotation_type_name = '{{ it.type.name }}';
                    {% if it.type.primitive == "Point" %}
                         x_absolute = {{ it.individualtagpoint.x }};
                         y_absolute = {{ it.individualtagpoint.y }};

                         x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                         y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;

                            var point = new fabric.Circle({
                                radius: 2,
                                fill: annotation_type_color,
                                left: x_relative,
                                top: y_relative,
                                name: annotation_type_name,
                                selectable: false,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                canvas_width: canvas.width
                            });

                            point.scaleX = scaleX;
                            point.scaleY = scaleY;
                            canvas.add(point);
                    {% elif it.type.primitive == "Box" %}
                        x_absolute = {{ it.individualtagbox.x_top_left }};
                        y_absolute = {{ it.individualtagbox.y_top_left }};
                        width_box = {{ it.individualtagbox.width }};
                        height_box = {{ it.individualtagbox.height }};

                        x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                        y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;
                        w_relative = (width_box * canvas.width)/canvas.backgroundImage.width;
                        h_relative = (height_box * canvas.width)/canvas.backgroundImage.width;

                        let rect = new fabric.Rect({
                            left: x_relative,
                            top: y_relative,
                            name: annotation_type_name,
                            width: w_relative,
                            height: h_relative,
                            selectable: false,
                            lockMovementX: false,
                            lockMovementY: false,
                            lockScalingX: false,
                            lockScalingY: false,
                            hasRotatingPoint: false,
                            fill: false,
                            stroke: annotation_type_color,
                            strokeWidth: 1.5,
                            strokeUniform: true,
                            canvas_width: canvas.width
                        });
                        canvas.add(rect);
                    {% elif it.type.primitive == 'Polygon' %}
                        var polyId = {{ it.individualtagcurve.id }};
                        var polyPoints = [];
                        var index = 0;

                        {% for p in it.individualtagcurve.points %}
                            x_absolute = {{ p.x }};
                            y_absolute = {{ p.y }};

                            x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                            y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;

                            var circle = new fabric.Circle({
                                radius: 2,
                                fill: annotation_type_color,
                                left: x_relative,
                                top: y_relative,
                                name: annotation_type_name,
                                selectable: true,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                originX:'center',
                                originY: 'center',
                                polyId: polyId,
                                id: index,
                                padding:10
                            });
                            circle.scaleX = scaleX;
                            circle.scaleY = scaleY;
                            canvas.add(circle);
                            canvas.bringToFront(circle);
                            polyPoints.push({x:x_relative, y:y_relative, id: index, polyId: polyId});
                            index++;
                        {% endfor %}
                        var polygon = new fabric.Polygon(polyPoints,{
                            name: annotation_type_name,
                            fill: annotation_type_color,
                            stroke: annotation_type_color,
                            strokeWidth: 1.5,
                            opacity: 0.2,
                            hasControls: false,
                            hasBorders: false,
                            selectable: false,
                            lockMovementX: true,
                            lockMovementY: true,
                            lockScalingX: true,
                            lockScalingY: true,
                            objectCaching:false,
                            strokeUniform: true,
                            polyId: polyId,
                            canvas_width: canvas.width
                        });
                        canvas.add(polygon);
                    {% elif it.type.primitive == 'Curve' %}
                        var polyId = {{ it.individualtagcurve.id }};
                        var polyPoints = [];
                        var index = 0;

                        {% for p in it.individualtagcurve.points %}
                            x_absolute = {{ p.x }};
                            y_absolute = {{ p.y }};

                            x_relative = (x_absolute * canvas.width)/canvas.backgroundImage.width;
                            y_relative = (y_absolute * canvas.width)/canvas.backgroundImage.width;

                            var circle = new fabric.Circle({
                                radius: 2,
                                fill: annotation_type_color,
                                top: y_relative,
                                left: x_relative,
                                name: annotation_type_name,
                                selectable: false,
                                lockMovementX: false,
                                lockMovementY: false,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasRotatingPoint: false,
                                polyId: polyId,
                                id:index,
                                originX:'center',
                                originY:'center',
                                padding:10

                            });
                            circle.scaleX = scaleX;
                            circle.scaleY = scaleY;
                            canvas.add(circle);
                            canvas.bringToFront(circle);
                            polyPoints.push({x:x_relative, y:y_relative, id: index, polyId: polyId});
                            index++;
                        {% endfor %}
                        var polyline = new fabric.Polyline(polyPoints,{
                            name: annotation_type_name,
                            stroke: annotation_type_color,
                            strokeWidth: 1.5,
                            fill: false,
                            selectable: false,
                            objectCaching:false,
                            strokeUniform: true,
                            lockMovementX: true,
                            lockMovementY: true,
                            lockScalingX: true,
                            lockScalingY: true,
                            polyId: polyId,
                            canvas_width: canvas.width
                        });
                        canvas.add(polyline);
                    {% endif %}
                {% endfor %}
                canvas.renderAll();
            {% endif %}
        }


        /**
         * REMOVER EVENTOS
         * Desactiva los eventos táctiles y de ratón relacionados con la realización de anotaciones, y los eventos de ratón para realizar panning.
         */
        function removeEvents() {
            canvas.isDrawingMode = false;
            canvas.selection = false;
            //EVENTOS TÁCTILES
            container.removeEventListener('touchstart', touchStartPoint);
            container.removeEventListener('touchstart', touchStartBox);
            container.removeEventListener('touchend', touchEnd);
            container.removeEventListener('touchmove', touchMoveBox);
            container.removeEventListener('touchstart', touchStartPolygon);
            container.removeEventListener('touchstart', touchStartCurve);

            //EVENTOS MOUSE
            container.removeEventListener('mousedown', touchStartPoint);
            container.removeEventListener('mousedown', touchStartBox);
            container.removeEventListener('mouseup', touchEnd);
            container.removeEventListener('mousemove', touchMoveBox);
            container.removeEventListener('mousedown', touchStartPolygon);
            container.removeEventListener('mousedown', touchStartCurve);
            canvas.off('mouse:down', panningTrue);
            canvas.off('mouse:up', panningFalse);
            canvas.off('mouse:move', movePanning);
        }


        /**
         * ANOTACIÓN PUNTO
         */
        function touchStartPoint(evt) {
            if ((evt.touches && evt.touches[0].touchType === "stylus") || evt.type == 'mousedown'){
                pointerdown = true;
                var pointer = canvas.getPointer(evt);
                pos_x = pointer.x;
                pos_y = pointer.y;
                var point = new fabric.Circle({
                    radius: 2,
                    fill: color_tag,
                    top: pos_y,
                    left: pos_x,
                    name: name_tag,
                    selectable: false,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: true,
                    lockScalingY: true,
                    hasRotatingPoint: false,
                    originX: 'center',
                    originY: 'center',
                    canvas_width: canvas.width
                });

                    point.scaleX = scaleX;
                    point.scaleY = scaleY;
                    console.log(point.left, " - ", point.top);


                canvas.add(point);
                //canvas.renderAll();

            }
        }
        function touchEnd(evt) {
            if ((evt.touches && evt.touches[0].touchType === "stylus") || evt.type == 'mouseup'){
                pointerdown = false;
                canvas.renderAll();
            }
        }
        function point(name_point, color_point) {
            pointerdown = false;
            name_tag = name_point;
            color_tag = color_point;
            removeEvents();
            container.addEventListener('touchstart', touchStartPoint);
            container.addEventListener('touchend', touchEnd);
            //EVENTOS MOUSE
            container.addEventListener('mousedown', touchStartPoint);
            container.addEventListener('mouseup', touchEnd);
        }

        /**
         * ANOTACIÓN CAJA
         */
        function touchStartBox(evt) {
            if ((evt.touches && evt.touches[0].touchType === "stylus") || evt.type == 'mousedown'){
                pointerdown = true;
                var pointer = canvas.getPointer(evt);
                pos_x = pointer.x; //posicion inicial
                pos_y = pointer.y;
                var pointer = canvas.getPointer(evt);
                rect = new fabric.Rect({
                    left: pos_x,
                    top: pos_y,
                    name: name_tag,
                    width: pointer.x - pos_x,
                    height: pointer.y - pos_y,
                    selectable: false,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: true,
                    lockScalingY: true,
                    hasRotatingPoint: false,
                    fill: false,
                    stroke: color_tag,
                    strokeWidth: stroke,
                    strokeUniform: true,
                    canvas_width: canvas.width
                });
                canvas.add(rect);
            }
        }
        function touchMoveBox(evt) {
            if ((evt.touches && evt.touches[0].touchType === "stylus") || evt.type == 'mousemove'){
                if (!pointerdown) return;
                var pointer = canvas.getPointer(evt);
                if (pos_x > pointer.x) {
                    rect.set({
                        left: Math.abs(pointer.x)
                    });
                }
                if (pos_y > pointer.y) {
                    rect.set({
                        top: Math.abs(pointer.y)
                    });
                }
                rect.set({
                    width: Math.abs(pos_x - pointer.x)
                });
                rect.set({
                    height: Math.abs(pos_y - pointer.y)
                });
                canvas.renderAll();
            }
        }
        function box(name_box, color_box) {
            pointerdown = false;
            name_tag = name_box;
            color_tag = color_box;
            removeEvents();
            //EVENTOS TÁCTILES
            container.addEventListener('touchstart', touchStartBox);
            container.addEventListener('touchmove', touchMoveBox);
            container.addEventListener('touchend', touchEnd);
            //EVENTOS MOUSE
            container.addEventListener('mousedown', touchStartBox);
            container.addEventListener('mousemove', touchMoveBox);
            container.addEventListener('mouseup', touchEnd);
        }

        /*ANOTACIÓN POLÍGONO*/
        function polygon(name_polygon, color_polygon){

            if(polygonMode == true){
                polygonMode = false;
                polygonPoints = [];
                indexPoint = 0;
            }
            activeLine = false;
            polygonMode = true;
            pointerdown = false;
            name_tag = name_polygon;
            color_tag = color_polygon;
            removeEvents();
            var random = Math.floor(Math.random() * (999999 - 99 + 1)) + 99;
            polyId = new Date().getTime() + random;

            container.addEventListener('mousedown', touchStartPolygon);
            container.addEventListener('touchstart', touchStartPolygon);
        }
        function touchStartPolygon(evt) {

            if ((evt.touches && evt.touches[0].touchType === "stylus") || evt.type == 'mousedown'){
                if (polygonMode) {
                    var pointer = canvas.getPointer(evt);
                    pos_x = pointer.x;
                    pos_y = pointer.y;


                    var circle = new fabric.Circle({
                        radius: 2,
                        fill: color_tag,
                        left: pos_x,
                        top: pos_y,
                        name: name_tag,
                        originX: 'center',
                        originY: 'center',
                        selectable: false,
                        hasBorders: false,
                        hasControls: false,
                        id: indexPoint,
                        polyId: polyId,
                        padding:10
                    });

                    circle.scaleX = scaleX;
                    circle.scaleY = scaleY;
                    canvas.add(circle);
                    canvas.bringToFront(circle);

                    if(activeLine){
                        var pos = canvas.getPointer(evt);
                        var polygonPoints = activeLine.get("points");
                        polygonPoints.push({
                            x: pos.x,
                            y: pos.y,
                            polyId: polyId,
                            id: indexPoint
                        });
                        var polygon = new fabric.Polygon(polygonPoints, {
                             selectable: false,
                             objectCaching: false,
                             fill: color_tag,
                             stroke: color_tag,
                             strokeWidth: stroke,
                             opacity:0.2,
                             hasBorders: false,
                             hasControls: false,
                             name: name_tag,
                             polyId: polyId,
                             lockMovementX: true,
                             lockMovementY: true,
                             lockScalingX: true,
                             lockScalingY: true,
                             strokeUniform: true,
                             canvas_width: canvas.width
                         });
                        canvas.remove(activeLine);
                        canvas.add(polygon);
                        activeLine = polygon;
                    }
                    else{
                        var polygonPoints = [{x:pos_x,y:pos_y,polyId:polyId,id:indexPoint}];
                        polygon = new fabric.Polyline(polygonPoints);
                        activeLine = polygon;
                        canvas.add(polygon);
                    }

                    indexPoint++;
                    canvas.selection = false;
                }
            }
        }

        function curved(name_curve, color_curve){

            if(lineMode == true){
                lineMode = false;
                polylinePoints = [];
                indexPoint = 0;
            }
            activeLine = false;
            lineMode = true;
            pointerdown = false;
            name_tag = name_curve;
            color_tag = color_curve;
            removeEvents();

            var random = Math.floor(Math.random() * (999999 - 99 + 1)) + 99;
            polyId = new Date().getTime() + random;

            container.addEventListener('mousedown', touchStartCurve);
            container.addEventListener('touchstart', touchStartCurve);


        }
        function touchStartCurve(evt) {
             if ((evt.touches && evt.touches[0].touchType === "stylus") || evt.type == 'mousedown'){
                 if (lineMode) {
                    var pointer = canvas.getPointer(evt);
                    pos_x = pointer.x;
                    pos_y = pointer.y;

                    var circle = new fabric.Circle({
                        radius: 2,
                        fill: color_tag,
                        name: name_tag,
                        left: pos_x,
                        top: pos_y,
                        selectable: false,
                        hasBorders: false,
                        hasControls: false,
                        hasRotatingPoint:false,
                        lockMovementX: false,
                        lockMovementY: false,
                        lockScalingX: false,
                        lockScalingY: false,
                        objectCaching:false,
                        originX: 'center',
                        originY: 'center',
                        id: indexPoint,
                        polyId: polyId,
                        padding:10
                    });
                    circle.scaleX = scaleX;
                    circle.scaleY = scaleY;
                    canvas.add(circle);
                    canvas.bringToFront(circle);

                    if(activeLine){
                        var pos = canvas.getPointer(evt);
                        var polylinePoints = activeLine.get("points");
                        polylinePoints.push({
                            x: pos.x,
                            y: pos.y,
                            polyId: polyId,
                            id: indexPoint
                        });
                        var polyline = new fabric.Polyline(polylinePoints, {
                            selectable: false,
                            objectCaching: false,
                            strokeWidth: stroke,
                            strokeUniform: true,
                            name: name_tag,
                            stroke: color_tag,
                            fill: false,
                            hasBorders: false,
                            hasControls: false,
                            polyId: polyId,
                            canvas_width: canvas.width
                        });
                        canvas.remove(activeLine);
                        canvas.add(polyline);
                        activeLine = polyline;
                    }
                    else{
                        var polylinePoints = [{x:pos_x,y:pos_y,polyId:polyId,id:indexPoint}];
                        polyline = new fabric.Polyline(polylinePoints);
                        activeLine = polyline;
                        canvas.add(polyline);
                    }
                    indexPoint++;
                    canvas.selection = false;

                 }
             }
        }

        /**
         * SELECCIONAR ANOTACIONES
         * Activa a true la variable que indica si un objeto es seleccionable, pero solo para anotaciones caja y puntos
         */
        function select_tag() {
            panning = false;
            removeEvents();

            canvas.forEachObject(function (obj) {
                if(obj.type !='polyline' || obj.type !='polygon'){
                    obj.selectable = true;
                }
            });
            canvas.selection = true;
            canvas.renderAll();
        }

        /**
         * BORRAR ANOTACIONES
         * Borra las anotaciones seleccionadas
         */
        function delete_tag() {
            canvas.getActiveObjects().forEach((obj) => {
                canvas.remove(obj);
            });
            canvas.discardActiveObject().renderAll()
        }

        /**
         * GUARDAR ANOTACIONES
         * Se usa para guardar en la base de datos todas las anotaciones realizadas actualmente en el canvas
         */
        function save(){
            canvas.renderAll();

            var URL = "{% url 'save_tags' id_exp=exp.id id_image=image.id %}";
            var data = JSON.stringify(canvas.toDatalessJSON(['name', 'top', 'left', 'fill', 'stroke', 'polyId', 'id', 'canvas_width']));
            $.post(URL, {'canvas_data': data});
            document.getElementById("text-alert").innerText = gettext("saved");
            $('.alert').show();
        }

        /**
         * VALIDAR ANOTACIONES
         * Se usa para que el experto valide las anotaciones de un usuario básico
         */
        function validate() {
                var URL = "{% url 'validate' id_exp=exp.id id_image=image.id id_user=tag_image.user.id %}";
                var data = JSON.stringify(canvas.toDatalessJSON(['name', 'top', 'left', 'fill', 'stroke', 'polyId', 'id', 'canvas_width']));
                $.post(URL, {'canvas_data': data});
                document.getElementById("text-alert").innerText = gettext("validated");
                $('.alert').show();
        }

        /**
         * DESVALIDAR ANOTACIONES
         * Se usa para que el experto invalide las anotaciones que previamente han sido validadas
         */
        function invalidate(){
                var URL = "{% url 'invalidate' id_exp=exp.id id_image=image.id id_user=tag_image.user.id %}";
                $.post(URL);
                document.getElementById("text-alert").innerText = gettext("invalidated");
                $('.alert').show();
        }
    </script>
{% endblock %}



